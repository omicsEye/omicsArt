% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pcl_utils.r
\name{pcl.tsne}
\alias{pcl.tsne}
\title{Perform t-SNE Ordination}
\usage{
pcl.tsne(
  dat,
  D = NA,
  as = FALSE,
  asinsqrt = as,
  index = "bray/curtis",
  k = 2,
  seed = 1234
)
}
\arguments{
\item{dat}{A list containing at least an element 'x' which is the data matrix.}

\item{D}{Distance matrix. If NA, it will be computed from dat$x. Default is NA.}

\item{as}{Logical. If TRUE, performs arcsine transformation (deprecated parameter). Default is FALSE.}

\item{asinsqrt}{Logical. If TRUE, performs arcsine square root transformation. Default is the value of 'as'.}

\item{index}{Character string specifying the distance index to use when computing D. Default is "bray/curtis".}

\item{k}{Integer. The number of dimensions for t-SNE. Must be at least 2. Default is 2.}

\item{seed}{Integer. Random seed for reproducibility. Default is 1234.}
}
\value{
A list containing two elements:
  \item{points}{A matrix of t-SNE coordinates}
  \item{ordnames}{A character vector of dimension names}
}
\description{
This function performs t-Distributed Stochastic Neighbor Embedding (t-SNE) ordination
on the input data or distance matrix.
}
\details{
The function first checks if a distance matrix D is provided. If not, it computes
the distance matrix from the input data using the specified index.
If asinsqrt is TRUE, the data is transformed using an arcsine square root transformation
before computing distances. The t-SNE algorithm is then applied to the distance matrix.
}
\note{
This function requires the 'tsne' and 'labdsv' packages.
}
\examples{
\dontrun{
data <- list(x = matrix(rnorm(1000), ncol = 10))
rownames(data$x) <- paste0("Sample", 1:100)
result <- pcl.tsne(data, k = 3)
plot(result$points[, 1], result$points[, 2], main = "t-SNE plot")
}

}
